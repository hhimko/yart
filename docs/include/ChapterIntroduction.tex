\chapter{Introduction} \label{ch:Introduction}

Vision is the single most advanced of human senses, which plays a vital role in determining how we perceive and experience the world.
It is not a surprise, that an ever-increasing amount of research and advancement has been made in pursuit of creating more photorealistic imagery in the field of computer graphics. 
In recent years, the dynamic landscape of computer graphics has witnessed a revolutionary shift with the rise and advancement of ray tracing technology. 
Unlike conventional rasterization techniques, ray tracing follows physical principles of light propagation, resulting in unparalleled level of visual realism. 

This dissertation aims to explore and elucidate the intricate inner workings behind a ray tracing engine, delving into the underlying principles and various considerations involved in the creation of such a system.
In contrast to a more conventional approach of implementing ray tracing within a specialized GPU pipeline, the proposed solution has instead been developed entirely on the CPU. 
Significant differences between these two types of implementations are noteworthy, especially in how they handle parallel processing, which can impact the performance and efficiency of a ray tracing application. 
While the highly parallel nature of a GPU is often preferred for commercial, real-time rendering systems, a CPU side implementation allows for gaining a deep understanding of fundamental principles of computer graphics, without the added complexity of GPU programming.

\section{Ray Tracing}

The concept of ray tracing has gained increased interest in most recent years, having seen a convergence of various advancements in hardware, algorithms, and an ever-growing industry demand for realism.
Its origin however, dates back to as far as 16th century when it was first described by a german artist and theorist Albrecht DÃ¼rer \supercite{Hofmann1990}.
At its core, ray tracing is a graphics rendering technique, used to simulate the way light interacts with objects within a virtual environment. 
The process involves scattering rays of light from a virtual camera, tracing their paths as they travel and interact with a scene. 
Individual light rays are traced "backward", originating from the camera's viewpoint, as opposed to how they would be cast from a light source in a more realistic setting.
Doing so however, is many orders of magnitude more optimal, since only a small percent of rays emitted from a given light source actually make it directly into the camera's lens and contribute to the final image \supercite{Glassner1989}.
Each ray is projected through a pixel on the output image plane, determining it's color by testing for intersections and sampling materials of hit objects, as seen on \cref{fig:Introduction/RayTracing/rt1}. 

\vfill
\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.8\textwidth]{example-image-a}
    \caption{Simplified ray tracing model.}
    \label{fig:Introduction/RayTracing/rt1}
\end{figure}
\vfill

When colliding with an object, the ray gets reflected of the surface, refracted, or absorbed depending on the object's material. 
Reflected rays are traced recursively to calculate the final color of a particular pixel, until being absorbed or reaching a certain limit of bounces.  

By following the physically-based principles of light, ray tracing enables straightforward simulation of highly realistic optical effects, such as refraction, depth of field and soft shadows, in contrast to the traditional rendering method of rasterization, where producing similar results could be a difficult, or even an impossible task. 
The unmatched visual realism of ray tracing however does not come without cost. 
Ray tracing generally has a much greater computational cost, as compared to scanline rendering methods, which makes it a less performant algorithm of the two.
Until the late 2010s, creating an interactive ray tracing application for consumer hardware was generally considered as impossible.
Today, the ongoing development of commercial hardware and algorithmic advancements have made real-time ray tracing become feasible, making it a viable option for film production, video games, and commercial graphics applications.

\section{Related Work}

Numerous high-level ray tracing engines and APIs have been proposed for professional and commercial use since the dawn of physically-based computer graphics.
Each engine, having distinct capabilities, purpose, and inherent limitations, has contributed greatly to the advancement of computer graphics. 
Following, is a list of noteworthy entries in the vast catalogue of ray tracing systems.

\subsection{NVIDIA OptiX}

First introduced in 2010, OptiX \supercite{Parker2010} is a programmable ray tracing framework designed for NVIDIA GPUs.
It has been developed with focus on both high flexibility and performance, targeting highly parallel hardware architectures.
The core idea behind the OptiX engine, is dividing the rendering pipeline into a small set of programmable operations or \textit{shaders}, akin to how rasterization pipelines are deployed within OpenGL and Direct3D applications.
These user-specified shaders can be defined to form a variety of ray tracing-based systems, including offline rendering, collision detection systems, and scientific simulations such as sound propagation.
For representing the scene, OptiX employs a lightweight data structure, called the \textit{context}, used for binding shaders to the object-specific data they require.
The context bundles together shaders, geometry data, and acceleration structures in the form of connected graph nodes, resulting in high flexibility and reusability.
While OptiX is a powerful tool for scientific research and professional ray tracing development, it may not be as user-friendly for artists and designers looking for out-of-the-box solutions.

\subsection{Cycles}

Developed by the Blender Foundation, Cycles is an open-source ray tracing renderer 

\section{Outline}

This introductory chapter highlights the key purpose of this dissertation, provides background, and gives a brief outline of existing solutions. 
\cref{ch:Implementation} puts forward the proposed application, diving into implementation detail and various considerations involved with its development. The aim of chapter 3 is \dots
